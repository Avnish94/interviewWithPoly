# interviewWithPoly Avnish Asthana
## Instructions to run the project:
The files are located under the /Frontend/WASM directory of this repo. Navigate to the directory in the terminal and type "node server.js" to run the server. It should give a confirmation message saying that the server is running on port 3000. Then on Visual Studio Code (I saw in the instructions you guys use that), right on the client.html file and click "Open with live server". If this option is not there, go to the Exentions tab on Visual Studio Code, type "live server" and download the first extension. Once doing this the option to open with live server will be there. After it opens the client.html page, simply input two numbers and choose whether to compute the addition locally or via the server using the labeled buttons.
## Questions
### 1. How does your client "ask" the server to run the computation? Is there a way to do this without duplicating your libary SDK as an API?
  The client asks the server to run the computation via a clear communication protocol using an exposed HTTP API on the server using Node.js. We then define a route that the client and send POST requests to, via the url (ex. http://localhost:3000/?a=5&b=7), that follows a defined standard format. The client sends these requests using a Fetch API in JavaScript. We use a request handler on the server to take incoming requests, parse the url, and execute the requested computation using the shared WASM binary file. We avoid duplication of the library SDK by ensuring that the client and server use the same library, functions, and logic needed to execute the shared WASM code.
   
### 2. How do you make the library non-blocking (this is potentially outside of scope, but still interesting)
  We can make the library non-blocking by wrapping WASM functions in promises and by utilizing 'async' and 'await' keywords. This lets our program perform other tasks while the WebAssembly computations run, instead of waiting for them to end first. Additionally, callback functions can be passed to the WebAssembly functions such that the callback is invoked with the result when the computation is complete. Callbacks can be a good approach for handling asynchronous operations in both client and server evironments. On the server side, Node.js has a worker_threads module that can allow the heavy WASM computations to perform in separate threads and prevent the main loop from blocking. On the client side, there is a Web Workers module that can allow WebAssembly to run in a separate thread and prevent the main UI from blocking.
### 3. What are the benefits and drawbacks of this way of separating compute between the client and server?
  The benefits of separating compute between the client and server is that the program (or in this case the client) can dynamically decide where the best place is to perform computations based on how heavy the computation is, network conditions, and resources available on the server and client side. Additionally we get good code reusability since we can write the WASM logic once and run anywhere, thus avoiding code duplication and making maintainance easier. With the client-side resources available, clients with powerful hardware can make computations locally whereas lightweight software can offload those heavy tasks to a server. Depending on the network, resources, and nature of the task a program such as this can reduce latency by taking all these factors into account and dynamically deciding where is the best place to run these computations while making efficient use of resources. The drawbacks include needing network overhead, where the time to send and recieve server communications can impact the application's responsiveness and be reduced with a slower network. If many clients are requesting heavy computations from the server, then that can impact server performance as well. Data transfer and synchronization can be resource intensive and challangeing if frequent exchanges need to be made. Additionally, there may be security concerns if malicious clients tamper with the shared WASM code.


## Extra Credit Questions
### 1. Can you have the client automatically decide when to use the server vs the client?
  Yes you can if the client factors in the following: task complexity, network conditions, server availability, client-side resources. The system can look at all these conditions to dynamically figure out whether the client or server is the best place to make these computations. The system can use methods such as load balancing and adaptive execution behavior to assess the situation and make the best decision.
### 2. What kinds of computations would need to be on one or the other?
  On the client-side, the best kind of computations be any sort of low latency task, offline execution (like when Google Docs works even if the network is lost), tasks directly related to the UI, and tasks containing sensitive data. On the server-side, the best kind of computations would be computationally heavy tasks, large data aggregation, scalable application workloads, and tasks involving collaboration with multiple users.
### 3. Can you have the client manage some state as well, so that your client can be an MVC-style system and the server calls are just "internal" to the controller logic?
Yes, we can have this MVC style system. The Model will represent the data and logic of an application, in this case the two numbers to be added and the addition functin. The View will be the UI and can present the results of both client-side and server-side computations. The Controller connects the Model and View, handling user input, updating the model, and controlling the flow of data in the application. The client can manage the model, including local data and logic for client-side computations. The client's controller handles user interactions and makes decisions on whether to execute tasks locally or on the server. When server-side computations are needed, the controller initiates server calls as part of its logic. The server provides endpoints and APIs for executing specific communications. The server-side execution focues on performing complex tasks and returning the results to the client. The server can also handle security, authentication, and other server-specific concerns.
